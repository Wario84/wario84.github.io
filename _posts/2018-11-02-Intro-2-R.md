---
title: "A quick introduction to R."
output: github_document
---

<!--  FORMAT: https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet -->

# 1. Operators

The basic structure of the language is defined in terms of **operators**, they are the building blocks of the language. An easy way to think about them is terms of **special characters** that perform an **action** with a specific result. These are the most common operators:


|      | List of Operators                                             |
|------|---------------------------------------------------------------|
| -    | Minus, can be unary or binary                                 |
| +    | Plus, can be unary or binary                                  |
| !    | Unary not                                                     |
| ~    | Tilde, used for model formulae, can be either unary or binary |
| ?    | Help                                                          |
| :    | Sequence, binary (in model formulae: interaction)             |
| \*   | Multiplication, binary                                        |
| /    | Division, binary                                              |
| ^    | Exponentiation, binary                                        |
| %x%  | Special binary operators, x can be replaced by any valid name |
| %%   | Modulus, binary                                               |
| %/%  | Integer divide, binary                                        |
| %%   | Matrix product, binary                                        |
| %o%  | Outer product, binary                                         |
| %x%  | Kronecker product, binary                                     |
| %in% | Matching operator, binary (in model formulae: nesting)        |
| <    | Less than, binary                                             |
| >    | Greater                                                       |
| ==   | Equal to, binary                                              |
| >=   | Greater than or equal to, binary                              |
| <=   | Less than or equal to, binary                                 |
| &    | And, binary, vectorized                                       |
| &&   | And, binary, not vectorized                                   |
| \|   | Or, binary, vectorized                                        |
| \|\| | Or, binary, not vectorized                                    |
| <-   | Left assignment, binary                                       |
| ->   | Right assignment, binary                                      |
| \    | List subset, binary                                           |
|------|---------------------------------------------------------------|

# 2. Atomic Elements.
The atomic elements are the most fundamental building blocks of the **R** language. They are the most essential input of the language, here are the main types:


|                 | List of atomic elements.                            |
|-----------------|-----------------------------------------------------|
| 1L, 2L, ..., 10L| Integer                                             |
| 1.1, 4.5, 3.2,  | Numeric                                             | 
| "a", "BD", "f"  | Character                                           | 
| TRUE, FALSE     | Logical or boolean                                  |
| NA              | Not Available / Missing Values                      | 
|-----------------|-----------------------------------------------------|

<!--  More generally, they help us to manipulate variables, evaluate statements, construct functions and perform any sort of operation. -->

# 3. Lines and Chunks of Code.
Now we can use **operators + atomic elements** to write lines of code. **R** runs this lines of code following these two rules:

1. Similar to math, *chunks* are read and evaluated from *left* to *right*.
2. Similar to a book, *chunks* are read and evaluated from *top* to *botton*.

Lines of code are the use to perform analysis, evaluate statements and any sort of operation that you can imagine. Different from independet lines of code, a group of two or more lines used for a particular operation is called a **chunk** of code. But, before we get into them, practice your knowledge of operators and atomic elemnts to perform basic arithmetic operations. 

## Use R as a calculator.

Instruction: Solve this exercises by writting the correct atomic elements and operators to perform each arithmetic operation. These exercise can only evaluate a unique answer for each line. 

Rules

2. Use the **most simple** combination of atomic elements and operators in the **exact** order that is asked. For instance,  if asked to perform  `2 plus 3`, the answer has to be `2 + 3`, but not `3 + 2`. Additionally, you need to reduce each expersion to its simplest form. That is, `2 + 1 + 1 + 1` would also be incorrect, since `2 + 3` is the simplest expresion. Another problem would be to write parenthesis when it is not needed. For instance, `(2 + 3)` when only `2 + 3` is needed.
3. Leave a **space** or white space in between each operator and atomic element. For instance, write `2 + 3` but not `2+3`.

**Warning**: This rules are only for the purpose of solving the exercies. In your datascience work you are free to write as you please, but I strongly advice to keep your code simple and clear.



<div class="exercise">
    <div class="title">
      <h2>Exercise 01: Arithmetics using R</h2>
    </div>
    <div data-datacamp-exercise data-lang="r" data-height="350">
      <code data-type="pre-exercise-code"># no pec</code>
      <code data-type="sample-code">
        
        # Addition: 2 plus 3. 
        2 + 3

        # Subtraction: 5 minus 4.
        
        
        # Multiplication: 5 times 5.
        
        
        # Division: 10 divided by 2.
        

        # Exponentiation: 4 to the power of 3.
        
        
      </code>
      <code data-type="solution">
        
        # Addition: 2 plus 3. 
        2 + 3

        # Subtraction: 5 minus 4.
        5 - 4

        # Multiplication: 5 times 5.
        3 * 5

        # Division: 10 divided by 2.
        10 / 2        

        # Exponentiation: 4 to the power of 3.
        4^3
        
      </code>
      <code data-type="sct">
        msg = &quot;Do not remove the other arithmetic examples!&quot;
        test_output_contains(&quot;2^5&quot;, incorrect_msg = &quot;The exponentiation
        example
        is not correct. Write `2 ^ 5` on a new line.&quot;)
        test_output_contains(&quot;28 %% 6&quot;, incorrect_msg = &quot;There seems to be an
        issue with the modulo example. Write `28 %% 6` on a new line.&quot;)
        success_msg(&quot;Great job!.&quot;)
      </code>
      <div data-type="hint">
        <p>Another example of the modulo operator:
          <code>9 %% 2</code> equals
          <code>1</code>.
        </p>
      </div>
    </div>
  </div>


we can use the operators to perform basic algebraic operations and to
evaluate logical statements. The two main rules to read *chunks* of code in **R** are:


In the following *script* I show basic algebraic operations (addition, multiplication and division) and also basic evaluation of logical statements. Remember, similar to math, *parentheses* `()` are used to group a set of operations or statements toguether.

<script src="https://gist.github.com/Wario84/dede4f20b6fedc920b696d81810dbe95.js"></script>

<!-- ``` -->
<!-- # Addition and Substraction -->
<!-- 1 + 5 -->
<!-- 1 - 7 -->

<!-- # Multiplication -->
<!-- 5 * 6 -->

<!-- # Division -->
<!-- 3 / 2 -->

<!-- # Powers -->
<!-- 4 ^ -1 -->

<!-- # Use of brackets -->
<!-- 4 / (6 * 6) * (2 - 4) -->

<!-- # Integer division -->
<!-- 6 %/% 4 -->

<!-- # Returns the remainder -->
<!-- 6 %% 4 -->

<!-- # Series -->
<!-- 4:7 -->

<!-- # Logical Statements -->
<!-- (TRUE == FALSE) == FALSE -->

<!-- (F == F) == T -->

<!-- 4 > 5 -->

<!-- 7 < 2 -->

<!-- (6 * 7) == (7 * 6) -->

<!-- c(2, 3) == c(3, 2) -->

<!-- c(3, 2) == c(3, 2) -->

<!-- (3 + 2) & (2 + 3) == 5 -->

<!-- # Vectorized: Evaluates element by element -->
<!-- c(2, 3, 4) | c(2, 3, 4) == c(2, 3, 4) -->

<!-- # Not vectorlized, outputs a single statement -->
<!-- c(2, 3, 4) || c(2, 3, 4) == c(2, 3, 4) -->

<!-- c(2, 3) %in% c(2, 4, 3) -->
<!-- ``` -->

# Objects

**R** is an [object-oriented programming language](https://adv-r.hadley.nz/oo.html), which means for simplicity that everything aside the *operators* and *syntaxis* is defined an object.

This objects have specific *attributes* which can be retrieved by *functions*, such as: class `class(x)`, structure `str(x)`; type of `typeof(x)`. Unidimensional objects such as *vectors* and *lists* are compatible with the `length(x)` which returns their number of elements for instance. However, more complex objects (multidimensional), such as *matrices* and *data frames* have dimensions, returned by `dim(x)`, also `nrow(x)` and `ncol(x)` to estimate the number of rows and columns respectively.

Pay attention to the use of the *left assignment* `<-` for storing objects; the *parenthesis* `()` for declaring arguments of functions; and *brakets* `[]` or the *dollar* sign `$` for subsetting objects. 

## Vectors (Also called atomic vectors).

<script src="https://gist.github.com/Wario84/cd415690520f05bce0c481320e040043.js"></script>


 <!-- ```r  -->

<!--  ### Vectors #### -->

<!-- # Empty vectors -->
<!-- z <- NULL -->
<!-- class(z) -->
<!-- length(z) -->
<!-- typeof(z) -->


<!-- # Numeric Vectors -->
<!-- a <- c('a' = 2.3, 'b' = 4) -->
<!-- a -->

<!-- a1 <- c(4, 7) -->
<!-- names(a1) <- c('a', 'b') -->
<!-- a1 -->

<!-- c <- c(NA, 6, -Inf) -->
<!-- class(a) -->
<!-- length(a) -->
<!-- typeof(a) -->


<!-- # Integers -->
<!-- b <- c(2L, 9L) -->
<!-- class(b) -->
<!-- length(b) -->
<!-- typeof(b) -->

<!-- # Logical -->
<!-- d <- c(T, F) -->
<!-- class(d) -->
<!-- typeof(d) -->

<!-- # Character -->
<!-- e <- c("A", 'B') -->
<!-- class(e) -->
<!-- typeof(e) -->

<!-- # Factor (Categorical Variable) -->
<!-- f <- factor(1:2) -->
<!-- levels(f) <- c('male', "female") -->
<!-- nlevels(f) -->
<!-- levels(f) -->
<!-- is.ordered(f) -->

<!-- g <- -->
<!-- factor(1:3, -->
<!-- labels = c('poor', 'good', 'excelent'), -->
<!-- ordered = T) -->
<!-- is.ordered(g) -->

<!--  ``` -->

## Matrices.
Are 2-dimensional arrays of data of one single type of atomic object. Matrices help run statistical analysisand any kind of algorithm that requires mathematical manipulation. A key aspect of a matrix is that their type is inherited by one single atomic object. Create a matrix with a numeric vector as elements and run the **typeof** function. Then add an extra column but these time use a character vector and verify the change in the attributes of the object with **typeof**. Notice that you can not use mathematical operators if the matrix is *character* type.


<script src="https://gist.github.com/Wario84/174663009414a06a689d112f9e1122e0.js"></script>

<!-- # USE RStudio with a Markdown document to comment multiple lines: ctrl + shift + c -->
<!-- ```r  -->
<!-- ### Matrices #### -->
<!-- # Basic -->
<!-- A <- matrix(1:9, ncol = 3, byrow = T) -->
<!-- class(A) -->
<!-- typeof(A) -->
<!-- # Add a column with character elements -->
<!-- Z <- matrix(c(1:9, LETTERS[1:3]), ncol = 4, byrow = T) -->
<!-- class(Z) -->
<!-- typeof(Z) -->
<!-- # Math operators don't work. -->
<!-- Z+Z -->
<!-- # Chance the elements of the matrix -->
<!-- A[upper.tri(A)] <- 1 -->
<!-- A[lower.tri(A)] <- 2 -->
<!-- diag(A) <- 3 -->
<!-- A -->
<!-- # Combining vectors by column -->
<!-- B <- cbind(2:0, 1:3, 0:2) -->
<!-- B -->
<!-- # Combining vectors by row -->
<!-- C <- rbind(1:3, 4:6, 7:9) -->
<!-- C -->
<!-- ### Basic Linear Algebra #### -->
<!-- # Vector Operations -->
<!-- 4 * a -->
<!-- (a) ^ -1 -->
<!-- a + a1 -->
<!-- # M. Transpose -->
<!-- t(A) -->
<!-- # M. Addition -->
<!-- A + B - C -->
<!-- # Dot Product -->
<!-- A %*% B -->
<!-- # Cross Product -->
<!-- t(A) %*% B == crossprod(A, B) -->
<!-- # Inverse -->
<!-- C <- matrix(c(39L, 8L, 71L, 72L, 54L, 42L, 76L, 77L, 15L), ncol = 3) -->
<!-- D <- solve(C) -->
<!-- C %*% D -->
<!-- round(C %*% D) -->
<!-- # Eigen values and vectors -->
<!-- eigen(C) -->
<!-- e <- eigen(C)$vector -->
<!-- v <- eigen(C)$value -->
<!-- C %*% e[, 1] == v[1] * e[, 1] -->
<!-- all.equal(as.vector(C %*% e[, 1]), v[1] * e[, 1]) -->
<!-- ``` -->

## Data Frames
*Data Frames* have a more heterogeneous structure, whereas vectors an matrices belong to a specific *typeof* object, data frames can have multiple types in each column.

<script src="https://gist.github.com/Wario84/c4febe856a8e8124f98c02a13477849d.js"></script>

<!-- ```r -->
<!-- ## Basic df -->
<!-- df <- -->
<!--   data.frame( -->
<!--   A = LETTERS[1:5], -->
<!--   B = factor(letters[1:5]), -->
<!--   C = 1L:5L, -->
<!--   D = c(2.4, 2, 3, 9, 7) -->
<!--   ) -->

<!--   # Dimension (Number of rows and columns) -->
<!--   dim(df) -->

<!--   # nb. of columns -->
<!--   ncol(df) -->
<!--   # nb. of rows -->
<!--   nrow(df) -->
<!--   # Structure -->
<!--   str(df) -->
<!--   # Class of each column -->
<!--   lapply(df, class) -->
<!--   # basic statistics -->
<!--   summary(df) -->
<!--   # Print head -->
<!--   head(df, 3) -->
<!--   # Print bottom -->
<!--   tail(df) -->
<!-- ## Bipartide Projection (Useful for networks) -->
<!-- #Other examples and benchmarks: https://goo.gl/v4ZbnM   -->
<!-- bp <- data.frame(papers=c(rep('A',3), rep('B', 2), 'C'), authors=c(1:3, 2:3, 4)) -->
<!-- bp   -->
<!-- # Incidence Matrix -->
<!-- py <- table(bp) -->
<!-- py -->
<!-- # Adjacency Matrix -->
<!-- py <- crossprod(py) -->
<!-- py -->
<!-- ``` -->

## Functions

*Functions* are very usefull when we need to perfrom the same operation(s) multiple times.

<script src="https://gist.github.com/Wario84/d04917a054eb17ac0869c295993b03d7.js"></script>

<!-- ```r  -->

<!-- # Write a naive funtion of degree from an adjacency matrix -->
<!-- n <- 5 -->
<!-- A <- matrix(sample(0:1, n * n, replace = T), ncol = n) -->
<!-- rownames(A) <- LETTERS[1:n] -->
<!-- colnames(A) <- LETTERS[1:n] -->
<!-- #remove loops -->
<!-- diag(A) <- 0 -->

<!-- s.degree <- function(x) { -->
<!-- n <- ncol(x) -->
<!-- d <- x %*% rep(1, n) -->
<!-- colnames(d) <- 'Degree' -->
<!-- d -->
<!-- } -->

<!-- s.degree(A) -->

<!-- ``` -->

## Lists

*Lists* are the most flexible structure, we can store multiple objects of different classes. A *data frame* is a list with a particular structure. We can use `dput` function to print and store the structure of any object, also helps to create reproducible examples.[^3]

<script src="https://gist.github.com/Wario84/6306f9d675c6a90e038ae3f67f77b484.js"></script>

<!-- # Print the structure of the df -->
<!-- dput(df) -->

<!-- #Store a vector, matrix, data.frame, function and a list together -->
<!-- s <- list(c(1:3)) -->
<!-- l <- list( -->
<!--   factor = f, -->
<!--   matrix = A, -->
<!--   data.frame = df, -->
<!--   list = s) -->

<!-- # Structure   -->
<!-- str(l) -->

<!-- # Class of each element of a list. -->
<!-- lapply(l, class) -->


## Indexing Objects

The syntaxys for subsetting changes slightly from object to object, but
in general, we can subset in three ways: *nominal, numeric, logical*.
**Data frames** and **lists** use a special operator: **\$**.

<script src="https://gist.github.com/Wario84/f7e48eb4754f40c3e87ce55aaf61586b.js"></script>

<!-- ```r -->
<!-- ### Nominal #### -->
<!-- ## vectors ## -->
<!-- names(a) -->
<!-- a['a'] -->
<!-- a['b'] -->

<!-- ## matrices ## -->
<!-- A[c('A', 'C'), c('D', 'E')] -->

<!-- ## data.frames ## -->
<!-- df[c('A', 'D')] -->

<!-- ## list ## -->
<!-- l[c('factor', 'matrix')] -->

<!-- ### Numeric #### -->

<!-- ## vectors ## -->
<!-- a[1] -->

<!-- ## matrices ## -->
<!-- A[2:3, 4] -->

<!-- ## data.frames ## -->
<!-- df[1:5, 2:3] -->

<!-- ## list ## -->
<!-- # The matrix -->
<!-- l[2] -->
<!-- # Carefull, this is still a list -->
<!-- class(l[2]) -->
<!-- # To get the matrix, we use double brakets -->
<!-- class(l[[2]]) -->
<!-- # The second column of the matrix -->
<!-- l[[2]][, 2] -->

<!-- ### Logical #### -->

<!-- ## vectors ## -->
<!-- a[c(TRUE, FALSE)] -->

<!-- ## matrices ## -->
<!-- A[upper.tri(A)] -->

<!-- ## data.frames ## -->
<!-- df[, c(rep(FALSE, 3), TRUE)] -->

<!-- ## list ## -->
<!-- # Extract the data.frame -->
<!-- l[unlist(lapply(l, class)) == 'data.frame'] -->

<!-- ### Combinations ### -->
<!-- A[2:3, c('C', 'D')] -->

<!-- ### Special OP #### -->
<!-- #Subset a Column -->
<!-- df$A -->
<!-- #Subset the df in a list, an print column D -->
<!-- l$data.frame$C -->
<!-- l$matrix[,4] -->
<!-- ``` -->

## Control Flow

Basic structure of `if`, `else` and `ifelse` statetements.

<script src="https://gist.github.com/Wario84/05c739c815f793ffed9ad7ccbff7fb14.js"></script>

<!-- ```r -->
<!-- condition <- 7 -->
<!-- if (condition == 7) { -->
<!--   print('Yes it is...') -->
<!-- } -->

<!-- ## Is the graph connected? -->
<!-- # A graph is connected if there is a path between every pair of vertices. -->
<!-- # If degree > 0 for every vertex the graph is connected -->
<!-- diag(py) <- 0 -->

<!-- is.connected <- function(am) { -->
<!--   d <- s.degree(am) -->
<!--   if (all(d > 0)) { -->
<!--     print('Graph is connected') -->
<!--   } else{ -->
<!--     print('Graph is disconnected') -->
<!--   }} -->

<!-- py -->
<!-- is.connected(py) -->

<!-- ## Evaluate multiple conditions (and, or) -->
<!-- #Check if the am has multiple edges or loops, -->
<!-- #then, simplify before computing degree. -->

<!-- is.sim_multi <- function(am) { -->
<!--   #check for multiple edges -->
<!--   mult.ed <- any(am > 1) -->
<!--   #check for loops -->
<!--   loops <- sum(diag(am)) != 0 -->
<!--   type <- c('The graph has:', 'multi edges', 'and loops.') -->
<!--   if (mult.ed | loops) { -->
<!--     am[am > 1] <- 1 -->
<!--     diag(am) <- 0 -->
<!--     print(paste(type[c(T, mult.ed,  loops)], collapse = " ")) -->
<!--   } else { -->
<!--     print("The graph is simple") -->
<!--   } -->
<!-- } -->

<!-- is.sim_multi(B) -->
<!-- is.sim_multi(A) -->


<!-- # Count the number of edges, and vertices, if edges > vertices, count edges -->
<!-- # and print, if else, edges < vertices, count vertices, and print -->
<!-- # else, print equal -->
<!-- no.ver.edges <- function(am) { -->
<!--   #vertices -->
<!--   v <- ncol(am) -->
<!--   #edges -->
<!--   e <- sum(am > 0) -->
<!--   if (e > v) { -->
<!--     print(paste('Edges:', e)) -->
<!--   } else if (e < v) { -->
<!--     print(paste('Vertices:', v)) -->
<!--   } else{ -->
<!--     paste('Vertices and Edges:', v) -->
<!--   } -->
<!-- } -->

<!-- no.ver.edges(A) -->
<!-- no.ver.edges(B) -->


<!-- #### ifelse function #### -->
<!-- #if else function is very efficient but it's partially vectorize: -->
<!-- # Its output is the same length as input. -->

<!-- #The input is a vector of three(one is false) -->
<!-- c(4, 5, 7) > c(3, 9, 6) -->

<!-- # if else evaluates as any() -->
<!-- ifelse(4>7, "YES", "NO") -->
<!-- length(4>7) -->
<!-- ifelse(7>4, "YES", "NO") -->

<!-- ifelse(c(4, 5, 7) > c(3, 9, 6), 'YES', 'NO') -->
<!-- any(c(4, 5, 7) > c(3, 9, 6)) -->

<!-- # if else can be nested and the syntax it's tricky but efficient. -->
<!-- is.sym <- -->
<!--   function(am) { -->
<!--     ifelse(ncol(am) != nrow(am), -->
<!--            'Not symmetric', -->
<!--            ifelse(all(am[upper.tri(am)] == am[lower.tri(am)]), 'Symmetric', 'Squared')) -->
<!--   } -->
<!-- A -->
<!-- is.sym(A) -->
<!-- B[3, 2] <- 1 -->
<!-- B -->
<!-- is.sym(B) -->
<!-- ``` -->

## `lapply` family of functions

The `lapply` function takes a list as the first argument and applies a
function to all the elements of the list. The function has two main
advantages, first improves the readability of the code by avoiding the
overuse of loops. Secondly, `lapply` is more flexible in comparison to
the `apply` function, because can take a list of multiple non list
objects to perform functions over each element of the `list`.

<script src="https://gist.github.com/Wario84/641b9b04471e5ffd0cf817d323ac9cec.js"></script>

<!-- ```r -->
<!-- # Example of sum all the columns of a matrix -->
<!-- ma <- matrix(sample(1:100,25), ncol = 5, nrow = 5) -->

<!-- # Using a loop -->
<!-- col.cum <- vector('numeric', length = 0) -->
<!-- for(c in 1:ncol(ma)){col.cum <- c(col.cum, sum(ma[,c])) } -->
<!--   # Using the apply function -->
<!-- apply(ma,2,sum)==col.cum -->

<!-- # Example of sum each row of a matrix -->
<!-- # Using a loop -->
<!-- row.cum <- vector('numeric', length = 0) -->
<!-- for(r in 1:ncol(ma)){row.cum <- c(row.cum, sum(ma[r,])) } -->
<!--   # Using the apply function -->
<!-- apply(ma,1,sum)==row.cum -->
<!--   # Using linear algebra (For simpler functions is better to use linear algebra) -->
<!-- apply(ma,1,sum)==row.cum&c(ma%*%rep(1,ncol(ma))) -->

<!--  # Example, how many times a string [A-] appears in a column? -->
<!-- ma <- matrix(replicate(5, sample(LETTERS[1:10],5)), ncol = 5, nrow = 5, byrow = TRUE) -->
<!-- lvls <- unique(c(ma)) -->
<!-- apply(ma,2,function(x) {  -->
<!--   table(factor(x,levels=lvls)) -->
<!-- }) -->
<!-- ``` -->


<html>
<head>
  <meta charset="utf-8" />
  <title>DataCamp Light | Standalone example</title>
  <link rel='shortcut icon' type='image/x-icon' href='https://www.datacamp.com/assets/favicon.ico'/>
  <style>
    .exercise {
      margin: 50px;
    }
  </style>

  <script async src="https://cdn.datacamp.com/dcl-react.js.gz"></script>
<script async src='/cdn-cgi/bm/cv/669835187/api.js'></script></head>
<body>
  <div class="exercise">
    <div class="title">
      <h2>This is an python exercise with a plot</h2>
    </div>

    <div data-datacamp-exercise data-lang="python" data-height="auto">
      <code data-type="pre-exercise-code"></code>
      <code data-type="sample-code">
        import numpy as np
        import matplotlib.pyplot as plt

        x = np.arange(0, 5, 0.1);
        y = np.sin(x)
        plt.plot(x, y)
        plt.show()
      </code>
      <code data-type="solution"></code>
      <code data-type="sct"></code>
      <div data-type="hint">Just press 'Run'.</div>
    </div>
  </div>
  <div class="exercise">
    <div class="title">
      <h2>How it works</h2>
    </div>
    <div data-datacamp-exercise data-lang="r" data-height="500">
      <code data-type="pre-exercise-code"># no pec</code>
      <code data-type="sample-code">
        # Calculate 3 + 4
        3 + 4

        # Calculate 6 + 12
      </code>
      <code data-type="solution">
        # Calculate 3 + 4
        3 + 4

        # Calculate 6 + 12
        6 + 12</code>
      <code data-type="sct">
        test_output_contains(&quot;18&quot;, incorrect_msg = &quot;Make sure to add `6 + 12`
        on
        a new line. Do not start the line with a `#`, otherwise your R code is not executed!&quot;)
        success_msg(&quot;Awesome! See how the console shows the result of the R code you
        submitted? Now that you&#39;re familiar with the interface, let&#39;s get down to R
        business!&quot;)
      </code>
      <div data-type="hint">
        <p>Just add a line of R code that calculates the sum of 6 and 12, just like the
          example
          in the sample code!</p>
      </div>
    </div>
  </div>
  <div class="exercise">
    <div class="title">
      <h2>Arithmetic with R</h2>
    </div>
    <div data-datacamp-exercise data-lang="r" data-height="350">
      <code data-type="pre-exercise-code"># no pec</code>
      <code data-type="sample-code">
        # An addition
        5 + 5

        # A subtraction
        5 - 5

        # A multiplication
        3 * 5

        # A division
        (5 + 5) / 2

        # Exponentiation


        # Modulo
      </code>
      <code data-type="solution">
        # An addition
        5 + 5

        # A subtraction
        5 - 5

        # A multiplication
        3 * 5

        # A division
        (5 + 5) / 2

        # Exponentiation
        2 ^ 5

        # Modulo
        28 %% 6
      </code>
      <code data-type="sct">
        msg = &quot;Do not remove the other arithmetic examples!&quot;
        test_output_contains(&quot;2^5&quot;, incorrect_msg = &quot;The exponentiation
        example
        is not correct. Write `2 ^ 5` on a new line.&quot;)
        test_output_contains(&quot;28 %% 6&quot;, incorrect_msg = &quot;There seems to be an
        issue with the modulo example. Write `28 %% 6` on a new line.&quot;)
        success_msg(&quot;Great! Head over to the next exercise.&quot;)
      </code>
      <div data-type="hint">
        <p>Another example of the modulo operator:
          <code>9 %% 2</code> equals
          <code>1</code>.
        </p>
      </div>
    </div>
  </div>
  <div class="exercise">
    <div class="title">
      <h2>Variable assignment</h2>
    </div>
    <div data-datacamp-exercise data-lang="r" data-height="350">
      <code data-type="pre-exercise-code"># no pec</code>
      <code data-type="sample-code">
        # Assign the value 42 to x
        x &lt;-

        # Print out the value of the variable x
        x
      </code>
      <code data-type="solution">
        # Assign the value 42 to x
        x &lt;- 42

        # Print out the value of the variable x
        x
      </code>
      <code data-type="sct">
        test_object(&quot;x&quot;, undefined_msg = &quot;Make sure to define a variable `x`.&quot;,
        incorrect_msg = &quot;Make sure that you assign the correct value to `x`.&quot;)
        success_msg(&quot;Good job! Have you noticed that R does not print the value of a
        variable to the console when you did the assignment? `x &lt;- 42` did not generate
        any
        output, because R assumes that you will be needing this variable in the future.
        Otherwise you wouldn&#39;t have stored the value in a variable in the first place,
        right? Proceed to the next exercise!&quot;)
      </code>
      <div data-type="hint">
        <p>Look at how the value 4 was assigned to
          <code>my_variable</code> in the exercise&#39;s assignment. Do the exact same
          thing
          in the editor, but now assign 42 to the variable
          <code>x</code>.
        </p>
      </div>
    </div>
  </div>
  <div class="exercise">
    <div class="title">
      <h2>Variable assignment (2)</h2>
    </div>
    <div data-datacamp-exercise data-lang="r" data-height="350">
      <code data-type="pre-exercise-code"># no pec</code>
      <code data-type="sample-code">
        # Assign the value 5 to the variable my_apples


        # Print out the value of the variable my_apples
      </code>
      <code data-type="solution">
        # Assign the value 5 to the variable my_apples
        my_apples &lt;- 5

        # Print out the value of the variable my_apples
        my_apples
      </code>
      <code data-type="sct">
        test_object(&quot;my_apples&quot;,
        undefined_msg = &quot;Please make sure to define a variable `my_apples`.&quot;,
        incorrect_msg = &quot;Make sure that you assign the correct value to `my_apples`.&quot;)
        test_output_contains(&quot;my_apples&quot;, incorrect_msg = &quot;Have you
        explicitly
        told R to print out the `my_apples` variable to the console?&quot;)
        success_msg(&quot;Great! Continue to the next exercise!&quot;)
      </code>
      <div data-type="hint">
        <p>Remember that if you want to assign a number or an object to a variable in R, you
          can
          make use of the assignment operator
          <code>&lt;-</code>. Alternatively, you can use
          <code>=</code>, but
          <code>&lt;-</code> is widely preferred in the R community.
        </p>
      </div>
    </div>
  </div>
  <div class="exercise">
    <div class="title">
      <h2>Variable assignment (3)</h2>
    </div>
    <div data-datacamp-exercise data-lang="r" data-height="350">
      <code data-type="pre-exercise-code"># no pec</code>
      <code data-type="sample-code">
        # Assign a value to the variables my_apples and my_oranges
        my_apples &lt;- 5


        # Add these two variables together


        # Create the variable my_fruit
      </code>
      <code data-type="solution">
        # Assign a value to the variables my_apples and my_oranges
        my_apples &lt;- 5
        my_oranges &lt;- 6

        # Add these two variables together
        my_apples + my_oranges

        # Create the variable my_fruit
        my_fruit &lt;- my_apples + my_oranges
      </code>
      <code data-type="sct">
        test_object(&quot;my_apples&quot;, incorrect_msg = &quot;Keep the line that assigns
        5 to
        `my_apples`.&quot;)
        test_object(&quot;my_oranges&quot;, incorrect_msg = &quot;Keep the line that assigns
        6
        to `my_oranges`.&quot;)
        test_output_contains(&quot;my_apples + my_oranges&quot;,
        incorrect_msg = &quot;Make sure to print out the result of adding `my_apples` and
        `my_oranges`. The code example in the description already gives away the answer to
        this
        instruction!&quot;)
        msg &lt;- &quot;Have you used `my_fruit &lt;- my_apples + my_oranges` to create the
        `my_fruit` variable?&quot;
        test_object(&quot;my_fruit&quot;, undefined_msg = msg, incorrect_msg = msg)
        success_msg(&quot;Nice one! The great advantage of doing calculations with variables
        is
        reusability. If you just change `my_apples` to equal 12 instead of 5 and rerun the
        script, `my_fruit` will automatically update as well. Continue to the next exercise.&quot;)
      </code>
      <div data-type="hint">
        <p>
          <code>my_fruit</code> is just the sum of
          <code>my_apples</code> and
          <code>my_oranges</code>. You can use the
          <code>+</code> operator to sum the two and
          <code>&lt;-</code> to assign that value to the variable
          <code>my_fruit</code>.
        </p>
      </div>
    </div>
  </div>
  <div class="exercise">
    <div class="title">
      <h2>Apples and oranges</h2>
    </div>
    <div data-datacamp-exercise data-lang="r" data-height="350">
      <code data-type="pre-exercise-code"># no pec</code>
      <code data-type="sample-code">
        # Assign a value to the variable my_apples
        my_apples &lt;- 5

        # Fix the assignment of my_oranges
        my_oranges &lt;- &quot;six&quot;

        # Create the variable my_fruit and print it out
        my_fruit &lt;- my_apples + my_oranges
        my_fruit
      </code>
      <code data-type="solution">
        # Assign a value to the variable my_apples
        my_apples &lt;- 5

        # Fix the assignment of my_oranges
        my_oranges &lt;- 6

        # Create the variable my_fruit and print it out
        my_fruit &lt;- my_apples + my_oranges
        my_fruit
      </code>
      <code data-type="sct">
        test_error(incorrect_msg = &quot;You can do this by setting the `my_oranges`
        variable to
        a numeric value, not a string!&quot;)
        test_object(&quot;my_apples&quot;, incorrect_msg = &quot;Make sure that `my_apples`
        still contains `5`.&quot;)
        test_object(&quot;my_oranges&quot;, incorrect_msg = &quot;Make sure that
        `my_oranges` is
        equal to `6`.&quot;)
        test_object(&quot;my_fruit&quot;, incorrect_msg = &quot;The value of `my_fruit` is
        not
        correct. It should be 11, the sum of `my_apples` and `my_oranges`.&quot;)
        test_output_contains(&quot;my_fruit&quot;, incorrect_msg = &quot;Don&#39;t remove
        the
        line that prints out `my_fruit`.&quot;)
        success_msg(&quot;Awesome, keep up the good work! Continue to the next exercise.&quot;)
      </code>
      <div data-type="hint">
        <p>You have to assign the numeric value
          <code>6</code> to the
          <code>my_oranges</code> variable instead of the character value
          <code>&quot;six&quot;</code>. Note how the quotation marks are used to indicate
          that
          <code>&quot;six&quot;</code> is a character.
        </p>
      </div>
    </div>
  </div>
  <div class="exercise">
    <div class="title">
      <h2>Basic data types in R</h2>
    </div>
    <div data-datacamp-exercise data-lang="r" data-height="350">
      <code data-type="pre-exercise-code"># no pec</code>
      <code data-type="sample-code">
        # Change my_numeric to be 42
        my_numeric &lt;- 42.5

        # Change my_character to be &quot;universe&quot;
        my_character &lt;- &quot;some text&quot;

        # Change my_logical to be FALSE
        my_logical &lt;- TRUE
      </code>
      <code data-type="solution">
        # Change my_numeric to be 42
        my_numeric &lt;- 42

        # Change my_character to be &quot;universe&quot;
        my_character &lt;- &quot;universe&quot;

        # Change my_logical to be FALSE
        my_logical &lt;- FALSE
      </code>
      <code data-type="sct">
        test_object(&quot;my_numeric&quot;, incorrect_msg = &quot;Have you correctly changed
        the
        declaration of `my_numeric` so it contains the value 42?&quot;)
        test_object(&quot;my_character&quot;, incorrect_msg = &quot;Have you correctly
        changed
        `my_character` to `\&quot;universe\&quot;`? Don&#39;t forget the quotes!&quot;)
        test_object(&quot;my_logical&quot;, incorrect_msg = &quot;Have you correctly changed
        `my_logical` to `FALSE`? All letters of `FALSE` should be capitalized!&quot;)
        success_msg(&quot;Great work! Continue to the next exercise.&quot;)
      </code>
      <div data-type="hint">
        <p>Replace the values in the editor with the values that are provided in the
          exercise.
          For example:

          <code>my_numeric &lt;- 42</code> assigns the value 42 to the variable
          <code>my_numeric</code>.
        </p>
      </div>
    </div>
  </div>
  <div class="exercise">
    <div class="title">
      <h2>What's that data type?</h2>
    </div>
    <div data-datacamp-exercise data-lang="r" data-height="350">
      <code data-type="pre-exercise-code"># no pec</code>
      <code data-type="sample-code">
        # Declare variables of different types
        my_numeric &lt;- 42
        my_character &lt;- &quot;universe&quot;
        my_logical &lt;- FALSE

        # Check class of my_numeric
        class(my_numeric)

        # Check class of my_character


        # Check class of my_logical
      </code>
      <code data-type="solution">
        # Declare variables of different types:
        my_numeric &lt;- 42
        my_character &lt;- &quot;universe&quot;
        my_logical &lt;- FALSE

        # Check class of my_numeric
        class(my_numeric)

        # Check class of my_character
        class(my_character)

        # Check class of my_logical
        class(my_logical)
      </code>
      <code data-type="sct">
        msg &lt;- &quot;Do not change the declaration of the variables!&quot;
        lapply(c(&quot;my_numeric&quot;, &quot;my_character&quot;, &quot;my_logical&quot;),
        test_object, undefined_msg = msg, incorrect_msg = msg)
        patt &lt;- &quot;Have you included `class(%1$s)` to print out the data type of
        `%1$s`?&quot;
        test_output_contains(&quot;class(my_numeric)&quot;,
        incorrect_msg = &quot;Do not remove the code that prints out the type of
        `my_numeric`.&quot;)
        test_output_contains(&quot;class(my_character)&quot;,
        incorrect_msg = sprintf(patt, &quot;my_character&quot;))
        test_output_contains(&quot;class(my_logical)&quot;,
        incorrect_msg = sprintf(patt, &quot;my_logical&quot;))
        success_msg(&quot;Congratulations! This was the last exercise for this chapter. Head
        over to the next chapter to get immersed in the world of vectors!&quot;)
      </code>
      <div data-type="hint">
        <p>The code that prints the data type of
          <code>my_numeric</code> is already included; do a similar things for
          <code>my_character</code> and
          <code>my_logical</code>.
        </p>
      </div>
    </div>
  </div>

<script type="text/javascript">(function(){window['__CF$cv$params']={r:'60c84adf8f0efa94',m:'6264a6c7b7098b4664f0029861e33345e755ecfb-1609798256-1800-AZ5SiMx9+8i1DUaATF29pUU2DgD2hGBahMTLzCp0u9zdneaWsgKHvJYIb63Nx6Kzrq22t/E1NgZ80qHhsGzmOUnf6ustaizE64ZpsRpRyOr+rEzbRTMYNIUp1ONMTGQCO+iTTwZJ9vTD6t2y4viZZeePccInWm+gDseSQ66FC7lD',s:[0x2d0011f590,0x51d56ce6c4],}})();</script></body>
</html>
